def login(usuario, senha):
    app = Flask(__name__)
    chrome_options = Options()
    chrome_options.add_argument("--headless")  
    #endregion
#region Ativar modo headless
    chrome_options.add_argument("--disable-gpu")  
    #endregion
#region Desativar uso de GPU (recomendado no modo headless)
    chrome_options.add_argument("--window-size=1920x1080")  
    #endregion
#region Definir resolução
    chrome_options.add_argument("--no-sandbox")  
    #endregion
#region Necessário em alguns sistemas
    chrome_options.add_argument("--disable-dev-shm-usage")  
    #endregion
#region Prevenir problemas de memória
    navegador = webdriver.Chrome(options=chrome_options)
    def separar_data_horario(data_envio):
        
        #endregion
#region Expressão regular para capturar a data e o horário no formato dd/mm/aaaaHH:MM
        match = re.match(r"(\d{2}/\d{2}/\d{4})(\d{2}:\d{2})", data_envio)
        if match:
            data = match.group(1)  
            #endregion
#region A data
            horario = match.group(2)  
            #endregion
#region O horário
            return data, horario
        else:
            
            #endregion
#region Caso não encontre o formato esperado, retorna a data e horário vazio
            return data_envio, ""

    
    #endregion
#region Função para tratar alertas
    def handle_alert():
        try:
            
            #endregion
#region Verifica se há um alerta na página
            alert = WebDriverWait(navegador, 5).until(EC.alert_is_present())
            alert_text = alert.text
            print(f"Alerta encontrado: {alert_text}")
            
            
            #endregion
#region Verifica se o alerta é de sessão expirada
            if "Sua sessão foi expirada" in alert_text:
                print("Sessão expirada! Tentando reiniciar...")
                alert.accept()  
                #endregion
#region Aceita o alerta e tenta fazer login novamente
                
                #endregion
#region Realizar novamente o login ou redirecionar para a página de login.
                navegador.get("https://sigaa.ifsc.edu.br/sigaa/verTelaLogin.do")
            else:
                alert.accept()  
                #endregion
#region Aceitar o alerta caso não seja o de sessão expirada
        except:
            pass  
        #endregion
#region Inicializar o WebDriver

    
    #endregion
#region Acessar a página de login
    navegador.get("https://sigaa.ifsc.edu.br/sigaa/verTelaLogin.do")
    username = usuario
    password = senha

    
    #endregion
#region Acessar a página de login
    navegador.get("https://sigaa.ifsc.edu.br/sigaa/verTelaLogin.do")

    
    #endregion
#region Esperar até o campo de login aparecer
    WebDriverWait(navegador, 10).until(EC.presence_of_element_located((By.NAME, "user.login")))

    
    #endregion
#region Encontrar os campos de login
    username_field = navegador.find_element(By.NAME, "user.login")
    password_field = navegador.find_element(By.NAME, "user.senha")

    
    #endregion
#region Preencher os campos de login e submeter
    username_field.send_keys(username)
    password_field.send_keys(password)
    password_field.send_keys(Keys.RETURN)

#endregion
#region Ver se a senha ta errada

    elements = navegador.find_elements(By.XPATH, "//center[@style='color: #922; font-weight: bold;' and text()='Usuário e/ou senha inválidos']")
    
    if elements:
        print("Elemento encontrado!")
    else:
        print("Elemento não encontrado!")



    
    #endregion

#region Tratar alertas, caso ocorram
    handle_alert()
    rows = navegador.find_elements(By.XPATH, "//table/tbody/tr")
    atividades=[]
    erros = []
    for row in rows:
        try:
            # Capturando os elementos necessários
            data_element = row.find_element(By.CSS_SELECTOR, "td font[color='gray']")
            atividade_element = row.find_element(By.CSS_SELECTOR, "td small font[color='gray']")
            
            # Extraindo informações
            data_envio = data_element.text.strip()
            atividade_info = atividade_element.get_attribute("innerText").split("\n")
            materia = atividade_info[0].strip()
            
            # Filtrando a parte do nome da atividade
            if "Tarefa:" in atividade_info[1]:
                nome_atividade = atividade_info[1].split("Tarefa:")[-1].strip()
            elif "Avaliação:" in atividade_info[1]:
                nome_atividade = atividade_info[1].split("Avaliação:")[-1].strip()
            elif "Questionário:" in atividade_info[1]:
                nome_atividade = atividade_info[1].split("Questionário:")[-1].strip()
            else:
                nome_atividade = "Atividade não especificada"

            # Separando data e horário (ajuste conforme necessário)
            if " " in data_envio:  # Verifica se existe um espaço, o que indica que temos data e horário juntos
                data_envio, horario_envio = data_envio.split(" ", 1)  # Divide a string em data e horário
            else:
                horario_envio = ""  # Caso não tenha horário, deixa em branco

            # Armazenando a atividade no banco de dados
            atividade = {
                'data_envio': data_envio,
                'horario_envio': horario_envio,  # Agora com horário separado
                'materia': materia,
                'nome_atividade': nome_atividade
            }
            atividades.append(atividade)
        except Exception as e:
            print(f"Erro ao processar atividade: {e}")
            erros.append(e)
            continue
    if atividades:
        atv = atividades
    else:
        atv = '<p style="text-align: center;"> Nenhuma atividade encontrada.</p>'
    resultados = []
    nomes_turmas = []
    html_notas = []
    try:
        WebDriverWait(navegador, 5).until(EC.presence_of_element_located((By.ID, "form_acessarTurmaVirtual:turmaVirtual")))
        print(f"Acessando turma: BIOLOGIA")
        botao = navegador.find_element(By.ID, f"form_acessarTurmaVirtual:turmaVirtual")  
        #endregion
#region Altere para o método de localização correto (ID, Nome, XPath, etc.)
        botao.click()
        botao = navegador.find_element(By.CLASS_NAME, "itemMenuHeaderAlunos")  
        #endregion
#region Altere para o método de localização correto (ID, Nome, XPath, etc.)
        botao.click()
        botao = navegador.find_element(By.XPATH, "//div[text()='Frequência']")  
        #endregion
#region Altere para o método de localização correto (ID, Nome, XPath, etc.)
        botao.click()
        nomes_turmas.append("BIOLOGIA")
        html_notas.append(navegador.page_source)
    except:
        return "erro"
    
    #endregion
#region URL da página inicial
    url_inicial = "https://sigaa.ifsc.edu.br/sigaa/portais/discente/discente.jsf"
    navegador.get(url_inicial)

    
    #endregion
#region Loop para percorrer os IDs dinâmicos
    for x in range(1, 10):  
        #endregion
#region Ajuste o range conforme necessário
        try:
            
            #endregion
#region Gerar o seletor de ID dinâmico
            id_selector = f"form_acessarTurmaVirtualj_id_{x}:turmaVirtual"

            
            #endregion
#region Esperar o elemento com o ID dinâmico estar presente
            WebDriverWait(navegador, 5).until(EC.presence_of_element_located((By.ID, id_selector)))

            
            #endregion
#region Encontrar o elemento e obter o nome da turma
            elemento_turma = navegador.find_element(By.ID, id_selector)
            nome_turma = elemento_turma.text.strip()
            if nome_turma:  
                nomes_turmas.append(nome_turma)
                print(f"Acessando turma: {nome_turma}")
                elemento_turma.click()
                WebDriverWait(navegador, 10).until(
                    EC.element_to_be_clickable((By.XPATH, "//div[text()='Frequência']"))
                )
                botao_notas = navegador.find_element(By.XPATH, "//div[text()='Frequência']")
                botao_notas.click()
                
                html_notas.append(navegador.page_source)

                navegador.get(url_inicial)


        except Exception as e:
            erro_msg = f"Erro ao processar o ID {id_selector}: {str(e)}"
            erros.append(erro_msg)
            navegador.get(url_inicial) 
            continue

            #endregion

        


    resultado2 = []
    erros = []
    log_dir = r"app\logs"
    log_file = os.path.join(log_dir, "log.txt")

    try:
        for idx, html in enumerate(html_notas):
            soup = BeautifulSoup(html, 'html.parser')

            # Remove o último <th> na linha com id "trAval"
            tr = soup.find('tr', id='trAval')
            if tr:
                th_elements = tr.find_all('tr')
                if th_elements:
                    th_elements[-1].decompose()

            # Remove a última célula de cada linha de todas as tabelas
            for table in soup.find_all('table'):
                for row in table.find_all('tr'):
                    cells = row.find_all(['tr', 'td'])
                    if cells:
                        cells[-1].decompose()

            # Remove todas as ocorrências de "Alunos Matriculados"
            for element in soup.find_all(string=lambda text: "Alunos Matriculados" in text):
                element.replace_with(element.replace("Alunos Matriculados", ""))

            # Adiciona a div com a classe 'notas' ao resultado
            notas_div = soup.find('fieldset')
            if notas_div:
                div_str = str(notas_div)
                resultado2.append(f"<strong>{nomes_turmas[idx]}</strong>{div_str}<br><br><br><br>")
        
        # Converte o resultado final para string
        resultado = " ".join(resultado2)
        soup = BeautifulSoup(resultado, 'html.parser')

        # Itera pelas tabelas para remover colunas específicas
        for table in soup.find_all('table'):
            headers = table.find('tr').find_all('tr')
            indices_to_remove = [index for index, header in enumerate(headers) if header.text.strip().lower() in ['matrícula', 'nome']]
            for row in table.find_all('tr'):
                cells = row.find_all(['tr', 'td'])
                for index in sorted(indices_to_remove, reverse=True):
                    if index < len(cells):
                        cells[index].decompose()

        # Resultado final
        resultado_final = str(soup)

    except Exception as e:
        erros.append(f"Erro ao processar HTML: {e}")

    # Cria o diretório de logs, se necessário, e salva os erros
    os.makedirs(log_dir, exist_ok=True)
    with open(log_file, "w", encoding="utf-8") as arquivo:
        arquivo.write("\n".join(erros))
    if erros:
        print("Erros armazenados:", erros)

    print("Nomes das turmas coletados:", nomes_turmas)
    return resultado_final, atv